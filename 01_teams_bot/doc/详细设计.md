## Python Teams AI 机器人详细开发文档

### 1. 项目概述

本模块旨在开发一个 Microsoft Teams 机器人，该机器人能够接收用户消息，通过集成的 AI 服务（例如 Google Gemini API）处理消息，并将 AI 生成的回复发送回 Teams。机器人将使用 Python 和 Microsoft Bot Framework SDK 构建，并部署在自定义服务器上。

### 2. 核心功能

#### 2.1. 消息接收与处理

*   **功能描述：** 机器人需要能够接收来自 Microsoft Teams 的各种类型消息（文本消息是主要关注点），并对这些消息进行解析和处理。
*   **实现方法：**
    *   使用 `botbuilder-core` 库中的 `ActivityHandler` 类作为机器人基类。
    *   重写 `on_message_activity` 方法来处理用户发送的文本消息。此方法会在收到消息活动时被调用。
    *   在 `on_message_activity` 方法中，从 `turn_context.activity.text` 获取用户发送的原始消息内容。

#### 2.2. AI 服务集成（通用接口设计）

*   **功能描述：** 设计一套通用的 AI 服务接口，使得机器人能够灵活地集成不同的 AI 服务（如 Google Gemini, OpenAI GPT 等），并能方便地切换或扩展。
*   **实现方法：**

    1.  **定义抽象 AI 服务接口 (`AIServiceInterface`)：**
        *   创建一个抽象基类，定义所有 AI 服务必须实现的标准方法。
        *   **`__init__(self, config: dict)`**:
            *   **目的：** 初始化 AI 服务客户端。
            *   **参数：** `config` (dict) - 包含 AI 服务所需配置的字典（如 `api_key`, `model_name`, `endpoint_url` 等）。
            *   **行为：** 存储配置，验证必需项，调用 `_initialize_service()`。
            *   **异常：** 配置缺失时抛出 `ValueError`。
        *   **`_initialize_service(self)`**:
            *   **目的：** 执行特定于 AI 服务的初始化操作。
            *   **类型：** 受保护的抽象方法，由具体实现类提供。
        *   **`get_ai_response(self, message: str, conversation_history: list = None) -> str`**:
            *   **目的：** 向 AI 服务发送消息并获取回复。
            *   **参数：** `message` (str) - 用户消息；`conversation_history` (list, 可选) - 用于多轮对话的上下文。
            *   **返回值：** (str) AI 生成的文本回复。
            *   **异常：** 调用服务失败时返回通用错误消息。
        *   **`load_config_from_env(prefix: str) -> dict`**:
            *   **目的：** 提供静态方法，从环境变量加载特定服务的配置（如 `PREFIX_API_KEY`, `PREFIX_MODEL_NAME`）。
            *   **参数：** `prefix` (str) - 环境变量前缀。
            *   **返回值：** (dict) 包含加载配置的字典。

    2.  **实现具体的 AI 服务类：**
        *   为每种 AI 服务（如 Google Gemini, OpenAI GPT）创建一个继承自 `AIServiceInterface` 的具体实现类（例如 `GeminiAIService`, `OpenAIAIService`）。
        *   在每个实现类中，重写 `_initialize_service()` 和 `get_ai_response()` 方法，以适 ancak 该服务的 API 调用方式和配置需求。
        *   （可选）提供静态方法（如 `GeminiAIService.get_default_config()`）来简化配置加载。

    3.  **创建 AI 服务工厂 (`AIServiceFactory`)：**
        *   **`SUPPORTED_SERVICES` (dict)**: 映射服务类型字符串（如 `"gemini"`, `"openai"`）到对应的实现类。
        *   **`get_ai_service(service_type: str, config: dict = None) -> AIServiceInterface`**:
            *   **目的：** 根据服务类型和配置，返回正确的 AI 服务实例。
            *   **行为：** 使用工厂模式查找并实例化服务类。如果未提供 `config`，则尝试加载默认配置。
            *   **异常：** 服务类型不支持或配置缺失时抛出 `ValueError`。

    4.  **在机器人核心逻辑中集成：**
        *   **配置提供商：** 使用环境变量（如 `AI_SERVICE_PROVIDER`）指定要使用的 AI 服务类型。
        *   **实例化服务：** 在机器人类 (`MyBot`) 的初始化中，根据 `AI_SERVICE_PROVIDER` 使用 `AIServiceFactory` 获取 AI 服务实例。
        *   **调用服务：** 在处理消息的方法 (`on_message_activity`) 中，调用 AI 服务实例的 `get_ai_response()` 方法来获取 AI 回复。
        *   **对话历史管理：** （可选）实现对话历史的存储和传递，将其作为参数传递给 `get_ai_response()`。

    5.  **环境变量配置更新：**
        *   在 `.env` 文件中添加 `AI_SERVICE_PROVIDER` 变量，并为不同 AI 服务配置相应的密钥和模型名称（如 `GEMINI_API_KEY`, `OPENAI_API_KEY`）。

*   **依赖：** 确保 `requirements.txt` 包含所有需要的 AI SDK（如 `google-generativeai`, `openai`）以及 `python-dotenv`。

#### 2.3. AI 回复发送

*   **功能描述：** 将从 AI 服务获取的回复发送回 Microsoft Teams 用户。
*   **实现方法：**
    *   在 `on_message_activity` 方法中，使用 `turn_context.send_activity()` 方法发送 AI 的回复。
    *   `await turn_context.send_activity(f"AI 回复: {ai_response}")`。

#### 2.4. Web 服务器集成与消息路由 (使用 Flask)

*   **功能描述：** 创建一个 Flask Web 服务器来托管机器人逻辑，并配置一个端点来接收来自 Bot Framework 的消息。
*   **实现方法：**
    *   **依赖安装：** 确保 `requirements.txt` 中包含 `botbuilder-integration-flask`。
    *   **Bot Framework Adapter 配置：**
        *   初始化 `BotFrameworkAdapter` 和 `BotFrameworkAdapterSettings`，传入从 `.env` 文件加载的 `MicrosoftAppId` 和 `MicrosoftAppPassword`。
        *   `bot_adapter = BotFrameworkAdapter(BotFrameworkAdapterSettings(APP_ID, APP_PASSWORD))`
    *   **创建 Flask 应用：**
        *   导入 Flask 并创建一个应用实例

    *   **配置消息端点：**
        *   定义一个处理 POST 请求的路由函数（例如 `messages`），该函数接收 Flask 的 `request` 对象。
        *   在该函数内部，调用 `bot_adapter.process(req, bot.on_turn)` 来处理传入的消息活动。
        *   将此函数注册为 Flask 应用的一个路由，通常是 `/api/messages`。
        *   **重要提示：** `botbuilder-core` 的 `BotFrameworkAdapter.process` 方法设计时可能更侧重于 `aiohttp` 或其他异步框架。使用 Flask 时，推荐使用 `botbuilder-integration-flask` 库，它提供了专门为 Flask 设计的适配器，可以更顺畅地集成。如果直接使用 `BotFrameworkAdapter`，可能需要一些额外的适配工作来处理 Flask 的 `request` 对象。

    *   **运行服务器：**
        *   在 `if __name__ == "__main__":` 块中运行 Flask 应用。

#### 2.5. 环境变量管理

*   **功能描述：** 安全地管理敏感配置信息，如 Microsoft App ID、密码和 AI 服务 API 密钥。
*   **实现方法：**
    *   使用 `python-dotenv` 库。
    *   在项目根目录创建 `.env` 文件，并添加如下内容：
        ```dotenv
        MicrosoftAppId=YOUR_MICROSOFT_APP_ID
        MicrosoftAppPassword=YOUR_MICROSOFT_APP_PASSWORD
        GEMINI_API_KEY=YOUR_GEMINI_API_KEY
        ```
    *   在 Python 代码中加载：`load_dotenv()`。
    *   通过 `os.environ.get("VARIABLE_NAME")` 访问这些变量。

### 3. 部署与集成

#### 3.1. Teams 应用清单 (`manifest.json`)

*   **功能描述：** 定义机器人在 Teams 中的行为、名称、图标和权限。
*   **关键字段说明：**
    *   `$schema`: 指定清单文件的 JSON Schema 版本。
    *   `version`: 应用的版本号。
    *   `id`: **必须**与 Microsoft Entra ID 中注册的应用 ID 相同。
    *   `name`: 应用的短名称和全称。
    *   `description`: 应用的简短和详细描述。
    *   `icons`: 指定机器人图标的路径（彩色和轮廓）。
    *   `developer`: 开发者信息。
    *   `bots`: 配置机器人的属性，包括：
        *   `botId`: 同样是 Microsoft App ID。
        *   `scopes`: 机器人可以运行的上下文（个人、团队、群聊）。
        *   `supportsFiles`: 是否支持文件上传（此处为 `false`）。
        *   `isNotificationOnly`: 是否仅用于发送通知（此处为 `false`）。
    *   `webApplicationInfo`: 包含应用 ID 和 Bot Framework 资源。
    *   `validDomains`: **非常重要**，需要包含机器人服务部署后的域名（生产环境）和本地测试时的 Ngrok 域名。Teams 会验证这些域名。

#### 3.2. 本地测试

*   **功能描述：** 在本地环境中运行和调试机器人，确保其功能正常。
*   **实现方法：**
    *   **运行机器人：** `python app.py` (或包含 Flask 应用的主文件)。
    *   **端口转发：** 使用 `ngrok http <机器人端口>`（例如 `ngrok http 3978`）暴露本地端口。
    *   **配置 Bot Framework Emulator：**
        *   Bot URL: `https://<ngrok-url>/api/messages`
        *   Microsoft App ID: 从 `.env` 加载。
        *   Microsoft App Password: 从 `.env` 加载。
    *   **更新 Manifest：** 将 `manifest.json` 中的 `validDomains` 和 `messageEndpoint` 指向 Ngrok URL。
    *   **打包与上传：** 将 `manifest.json` 和图标打包成 `.zip`，然后在 Teams 中上传为自定义应用进行测试。

#### 3.3. 服务器部署 (使用 Flask)

*   **功能描述：** 将机器人服务部署到可公开访问的服务器上，使其能够被 Teams 平台调用。
*   **实现方法：**
    *   **服务器准备：** 选择合适的服务器环境（如 VPS, 云服务器）。
    *   **代码部署：** 将项目文件上传到服务器。
    *   **环境配置：**
        *   在服务器上设置 Python 虚拟环境。
        *   安装依赖：`pip install -r requirements.txt`。
        *   配置环境变量（`MicrosoftAppId`, `MicrosoftAppPassword`, `GEMINI_API_KEY`）。
    *   **运行应用：**
        *   使用 Gunicorn 运行 Flask 应用：
            `gunicorn --bind 0.0.0.0:<端口> --workers <数量> app:app`
            （假设您的 Flask 应用实例名为 `app`，并且在 `app.py` 文件中定义。如果您的机器人逻辑和 Flask 应用在不同的文件中，例如 `main.py` 包含 Flask 应用，`bot_logic.py` 包含 `MyBot` 类，则命令可能是 `gunicorn --bind 0.0.0.0:3978 --workers 4 main:app`）。
    *   **反向代理配置（使用 Nginx）：**
        *   确保服务器上已安装 Nginx。
        *   配置 Nginx 以监听公共域名（例如 `your-server-domain.com`）的 HTTPS 请求。
        *   设置 SSL 证书（例如 Let's Encrypt）以启用 HTTPS。
        *   配置 Nginx 的 `location` 块，将所有指向 `/api/messages` 的请求（或其他机器人端点）代理到您的 Flask 应用正在运行的本地端口（例如 `http://localhost:3978`）。
        *   **Nginx 配置示例 (`/etc/nginx/sites-available/your-bot`):**
          ```nginx
          server {
              listen 443 ssl;
              server_name your-server-domain.com;

              ssl_certificate /etc/letsencrypt/live/your-server-domain.com/fullchain.pem;
              ssl_certificate_key /etc/letsencrypt/live/your-server-domain.com/privkey.pem;
              include /etc/letsencrypt/options-ssl-nginx.conf;
              ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

              location /api/messages {
                  proxy_pass http://localhost:3978; # 假设 Flask 应用运行在 3978 端口
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
              }

              # 可以添加其他 location 块来处理静态文件等
          }
          ```
        *   启用 Nginx 配置：`sudo ln -s /etc/nginx/sites-available/your-bot /etc/nginx/sites-enabled/`，然后重新加载 Nginx：`sudo systemctl reload nginx`。
    *   **更新 Manifest：** 将 `manifest.json` 中的 `validDomains` 和 `messageEndpoint` 更新为服务器的实际域名（例如 `your-server-domain.com`）和部署后的机器人路径（例如 `https://your-server-domain.com/api/messages`）。

#### 3.4. Teams 应用安装

*   **功能描述：** 将打包好的机器人应用安装到 Teams 中。
*   **实现方法：**
    *   将 `manifest.json` 和图标文件打包成 `.zip`。
    *   在 Teams 中，导航到“应用” > “管理你的应用” > “上传自定义应用”。
    *   选择打包好的 `.zip` 文件进行上传和安装。

--- 

**总结更改：**

*   **依赖：** 添加 `botbuilder-integration-flask`。
*   **代码结构：** 使用 Flask 的路由 (`@app.route`) 来处理 `/api/messages` 端点。
*   **适配器：** 强烈建议使用 `botbuilder-integration-flask` 提供的 `FlaskAdapter` 来简化集成，而不是直接使用 `BotFrameworkAdapter`。
*   **运行命令：** 部署时使用 Gunicorn 运行 Flask 应用。

这份文档详细说明了每个功能点的实现方法和所需的技术细节。在实际开发中，请根据您的具体需求和选择的框架进行调整。