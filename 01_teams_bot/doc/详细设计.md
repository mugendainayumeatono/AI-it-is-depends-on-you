
## Python Teams AI 机器人详细开发文档

### 1. 项目概述

本模块旨在开发一个 Microsoft Teams 机器人，该机器人能够接收用户消息，通过集成的 AI 服务（例如 Google Gemini API）处理消息，并将 AI 生成的回复发送回 Teams。机器人将使用 Python 和 Microsoft Bot Framework SDK 构建，并部署在自定义服务器上。

### 2. 核心功能

#### 2.1. 消息接收与处理

*   **功能描述：** 机器人需要能够接收来自 Microsoft Teams 的各种类型消息（文本消息是主要关注点），并对这些消息进行解析和处理。
*   **实现方法：**
    *   使用 `botbuilder-core` 库中的 `ActivityHandler` 类作为机器人基类。
    *   重写 `on_message_activity` 方法来处理用户发送的文本消息。此方法会在收到消息活动时被调用。
    *   在 `on_message_activity` 方法中，从 `turn_context.activity.text` 获取用户发送的原始消息内容。

#### 2.2. AI 服务集成（以 Google Gemini 为例）

*   **功能描述：** 将接收到的用户消息发送给 AI 服务（如 Google Gemini API），获取 AI 生成的回复。
*   **实现方法：**
    *   **依赖安装：** 确保 `requirements.txt` 中包含 `google-generativeai` 和 `python-dotenv`。
    *   **API 密钥管理：**
        *   创建一个 `.env` 文件，并在其中存储 `GEMINI_API_KEY`。
        *   使用 `python-dotenv` 库加载环境变量：`from dotenv import load_dotenv; load_dotenv()`。
        *   配置 Gemini API：`import google.generativeai as genai; genai.configure(api_key=os.environ.get("GEMINI_API_KEY"))`。
    *   **模型初始化：**
        *   选择并初始化 Gemini 模型：`model = genai.GenerativeModel('gemini-pro')`。
        *   启动一个对话会话（如果需要保持对话历史）：`chat = model.start_chat(history=[])`。
    *   **调用 AI 服务：**
        *   在机器人的消息处理逻辑中（例如一个单独的 `get_ai_response` 方法），调用 Gemini API。
        *   使用 `chat.send_message(user_message)` 发送用户消息给模型。
        *   从返回的响应对象中提取 AI 生成的文本：`response.text.strip()`。
    *   **错误处理：** 为调用 AI 服务 API 的过程添加 `try-except` 块，捕获潜在的网络错误、API 错误等，并返回友好的错误提示给用户。

#### 2.3. AI 回复发送

*   **功能描述：** 将从 AI 服务获取的回复发送回 Microsoft Teams 用户。
*   **实现方法：**
    *   在 `on_message_activity` 方法中，使用 `turn_context.send_activity()` 方法发送 AI 的回复。
    *   `await turn_context.send_activity(f"AI 回复: {ai_response}")`。

#### 2.4. Web 服务器集成与消息路由 (使用 Flask)

*   **功能描述：** 创建一个 Flask Web 服务器来托管机器人逻辑，并配置一个端点来接收来自 Bot Framework 的消息。
*   **实现方法：**
    *   **依赖安装：** 确保 `requirements.txt` 中包含 `botbuilder-integration-flask`。
    *   **Bot Framework Adapter 配置：**
        *   初始化 `BotFrameworkAdapter` 和 `BotFrameworkAdapterSettings`，传入从 `.env` 文件加载的 `MicrosoftAppId` 和 `MicrosoftAppPassword`。
        *   `bot_adapter = BotFrameworkAdapter(BotFrameworkAdapterSettings(APP_ID, APP_PASSWORD))`
    *   **创建 Flask 应用：**
        *   导入 Flask 并创建一个应用实例：
            ```python
            from flask import Flask, request, Response
            from botbuilder.core.adapters import BotFrameworkAdapter, BotFrameworkAdapterSettings
            from botbuilder.core.teams import TeamsActivityHandler
            from botbuilder.schema import Activity, ActivityTypes
            import os
            from dotenv import load_dotenv

            load_dotenv()

            APP_ID = os.environ.get("MicrosoftAppId")
            APP_PASSWORD = os.environ.get("MicrosoftAppPassword")

            bot_adapter = BotFrameworkAdapter(
                BotFrameworkAdapterSettings(APP_ID, APP_PASSWORD)
            )
            # MyBot 类定义需要在此之前或在此处导入/定义
            # from my_bot_logic import MyBot # 假设 MyBot 类在 my_bot_logic.py 文件中
            # bot = MyBot()

            app = Flask(__name__)
            ```
    *   **配置消息端点：**
        *   定义一个处理 POST 请求的路由函数（例如 `messages`），该函数接收 Flask 的 `request` 对象。
        *   在该函数内部，调用 `bot_adapter.process(req, bot.on_turn)` 来处理传入的消息活动。
        *   将此函数注册为 Flask 应用的一个路由，通常是 `/api/messages`。
            ```python
            @app.route("/api/messages", methods=["POST"])
            async def messages():
                # 推荐使用 botbuilder-integration-flask 提供的 FlaskAdapter
                # from botbuilder.integration.flask import FlaskAdapter
                # flask_adapter = FlaskAdapter(bot, APP_ID, APP_PASSWORD)
                # return flask_adapter.process()

                # 如果直接使用 BotFrameworkAdapter，需要确保其兼容 Flask 的 request 对象
                # 这是一个简化的示例，实际可能需要更复杂的处理
                response = await bot_adapter.process(request, bot.on_turn)
                return Response(response.body, response.status_code, response.headers)

            ```
        *   **重要提示：** `botbuilder-core` 的 `BotFrameworkAdapter.process` 方法设计时可能更侧重于 `aiohttp` 或其他异步框架。使用 Flask 时，推荐使用 `botbuilder-integration-flask` 库，它提供了专门为 Flask 设计的适配器，可以更顺畅地集成。如果直接使用 `BotFrameworkAdapter`，可能需要一些额外的适配工作来处理 Flask 的 `request` 对象。

    *   **运行服务器：**
        *   在 `if __name__ == "__main__":` 块中运行 Flask 应用。
            ```python
            if __name__ == "__main__":
                # 如果使用 Flask 内置服务器进行开发
                # app.run(port=3978) # 端口可自定义

                # 对于生产部署，推荐使用 Gunicorn 或 uWSGI
                # 例如，使用 Gunicorn:
                # gunicorn --bind 0.0.0.0:3978 --workers 1 app:app
                # 注意：如果使用 Gunicorn，则不需要此处的 app.run()
                # 并且需要确保 MyBot 类被正确导入和实例化
                # 假设 MyBot 类在 app.py 文件中定义，则 app:app 是正确的
                # 如果 MyBot 在其他文件，例如 my_bot_logic.py，则需要调整
                # 例如：
                # from my_bot_logic import MyBot
                # bot = MyBot()
                # app.run(port=3978) # 开发时使用
                pass # 如果使用 Gunicorn 运行，则此行不需要
            ```

#### 2.5. 环境变量管理

*   **功能描述：** 安全地管理敏感配置信息，如 Microsoft App ID、密码和 AI 服务 API 密钥。
*   **实现方法：**
    *   使用 `python-dotenv` 库。
    *   在项目根目录创建 `.env` 文件，并添加如下内容：
        ```dotenv
        MicrosoftAppId=YOUR_MICROSOFT_APP_ID
        MicrosoftAppPassword=YOUR_MICROSOFT_APP_PASSWORD
        GEMINI_API_KEY=YOUR_GEMINI_API_KEY
        ```
    *   在 Python 代码中加载：`load_dotenv()`。
    *   通过 `os.environ.get("VARIABLE_NAME")` 访问这些变量。

### 3. 部署与集成

#### 3.1. Teams 应用清单 (`manifest.json`)

*   **功能描述：** 定义机器人在 Teams 中的行为、名称、图标和权限。
*   **关键字段说明：**
    *   `$schema`: 指定清单文件的 JSON Schema 版本。
    *   `version`: 应用的版本号。
    *   `id`: **必须**与 Microsoft Entra ID 中注册的应用 ID 相同。
    *   `name`: 应用的短名称和全称。
    *   `description`: 应用的简短和详细描述。
    *   `icons`: 指定机器人图标的路径（彩色和轮廓）。
    *   `developer`: 开发者信息。
    *   `bots`: 配置机器人的属性，包括：
        *   `botId`: 同样是 Microsoft App ID。
        *   `scopes`: 机器人可以运行的上下文（个人、团队、群聊）。
        *   `supportsFiles`: 是否支持文件上传（此处为 `false`）。
        *   `isNotificationOnly`: 是否仅用于发送通知（此处为 `false`）。
    *   `webApplicationInfo`: 包含应用 ID 和 Bot Framework 资源。
    *   `validDomains`: **非常重要**，需要包含机器人服务部署后的域名（生产环境）和本地测试时的 Ngrok 域名。Teams 会验证这些域名。

#### 3.2. 本地测试

*   **功能描述：** 在本地环境中运行和调试机器人，确保其功能正常。
*   **实现方法：**
    *   **运行机器人：** `python app.py` (或包含 Flask 应用的主文件)。
    *   **端口转发：** 使用 `ngrok http <机器人端口>`（例如 `ngrok http 3978`）暴露本地端口。
    *   **配置 Bot Framework Emulator：**
        *   Bot URL: `https://<ngrok-url>/api/messages`
        *   Microsoft App ID: 从 `.env` 加载。
        *   Microsoft App Password: 从 `.env` 加载。
    *   **更新 Manifest：** 将 `manifest.json` 中的 `validDomains` 和 `messageEndpoint` 指向 Ngrok URL。
    *   **打包与上传：** 将 `manifest.json` 和图标打包成 `.zip`，然后在 Teams 中上传为自定义应用进行测试。

#### 3.3. 服务器部署 (使用 Flask)

*   **功能描述：** 将机器人服务部署到可公开访问的服务器上，使其能够被 Teams 平台调用。
*   **实现方法：**
    *   **服务器准备：** 选择合适的服务器环境（如 VPS, 云服务器）。
    *   **代码部署：** 将项目文件上传到服务器。
    *   **环境配置：**
        *   在服务器上设置 Python 虚拟环境。
        *   安装依赖：`pip install -r requirements.txt`。
        *   配置环境变量（`MicrosoftAppId`, `MicrosoftAppPassword`, `GEMINI_API_KEY`）。
    *   **运行应用：**
        *   使用 Gunicorn 运行 Flask 应用：
            `gunicorn --bind 0.0.0.0:<端口> --workers <数量> app:app`
            （假设您的 Flask 应用实例名为 `app`，并且在 `app.py` 文件中定义。如果您的机器人逻辑和 Flask 应用在不同的文件中，例如 `main.py` 包含 Flask 应用，`bot_logic.py` 包含 `MyBot` 类，则命令可能是 `gunicorn --bind 0.0.0.0:3978 --workers 4 main:app`）。
    *   **反向代理配置（使用 Nginx）：**
        *   确保服务器上已安装 Nginx。
        *   配置 Nginx 以监听公共域名（例如 `your-server-domain.com`）的 HTTPS 请求。
        *   设置 SSL 证书（例如 Let's Encrypt）以启用 HTTPS。
        *   配置 Nginx 的 `location` 块，将所有指向 `/api/messages` 的请求（或其他机器人端点）代理到您的 Flask 应用正在运行的本地端口（例如 `http://localhost:3978`）。
        *   **Nginx 配置示例 (`/etc/nginx/sites-available/your-bot`):**
          ```nginx
          server {
              listen 443 ssl;
              server_name your-server-domain.com;

              ssl_certificate /etc/letsencrypt/live/your-server-domain.com/fullchain.pem;
              ssl_certificate_key /etc/letsencrypt/live/your-server-domain.com/privkey.pem;
              include /etc/letsencrypt/options-ssl-nginx.conf;
              ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

              location /api/messages {
                  proxy_pass http://localhost:3978; # 假设 Flask 应用运行在 3978 端口
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
              }

              # 可以添加其他 location 块来处理静态文件等
          }
          ```
        *   启用 Nginx 配置：`sudo ln -s /etc/nginx/sites-available/your-bot /etc/nginx/sites-enabled/`，然后重新加载 Nginx：`sudo systemctl reload nginx`。
    *   **更新 Manifest：** 将 `manifest.json` 中的 `validDomains` 和 `messageEndpoint` 更新为服务器的实际域名（例如 `your-server-domain.com`）和部署后的机器人路径（例如 `https://your-server-domain.com/api/messages`）。

#### 3.4. Teams 应用安装

*   **功能描述：** 将打包好的机器人应用安装到 Teams 中。
*   **实现方法：**
    *   将 `manifest.json` 和图标文件打包成 `.zip`。
    *   在 Teams 中，导航到“应用” > “管理你的应用” > “上传自定义应用”。
    *   选择打包好的 `.zip` 文件进行上传和安装。

---

**总结更改：**

*   **依赖：** 添加 `botbuilder-integration-flask`。
*   **代码结构：** 使用 Flask 的路由 (`@app.route`) 来处理 `/api/messages` 端点。
*   **适配器：** 强烈建议使用 `botbuilder-integration-flask` 提供的 `FlaskAdapter` 来简化集成，而不是直接使用 `BotFrameworkAdapter`。
*   **运行命令：** 部署时使用 Gunicorn 运行 Flask 应用。

这份文档详细说明了每个功能点的实现方法和所需的技术细节。在实际开发中，请根据您的具体需求和选择的框架进行调整。
